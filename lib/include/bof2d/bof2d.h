/*
 * Copyright (c) 2020-2030, Onbings. All rights reserved.
 *
 * THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 * KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 * PURPOSE.
 *
 * This module defines the bof module interface for 2d manip
 *
 * Author:      Bernard HARMEL: onbings@gmail.com
 * Web:			    onbings.dscloud.me
 * Revision:    1.0
 *
 * History:
 *
 * V 1.00  Nov 13 2022  BHA : Initial release
 */
#pragma once
#if defined(BOF2D_VLD)
#pragma message("!!!!!!!!!!!!! Visual Studio Detector Activated !!!!!!!!!!!!!")
#include <bofstd/vld/include/vld.h>
#endif

#include <bofstd/bofstd.h>
#include <bof2d_export.h> //Autogenerated by cmake
#include <cstdint>

#define BOF2D                         onbings::bof2d
#define BEGIN_BOF2D_NAMESPACE()       namespace onbings { namespace bof2d {
#define END_BOF2D_NAMESPACE()         } }
#define USE_BOF2D_NAMESPACE()         using namespace BOF2D;


BEGIN_BOF2D_NAMESPACE()
#define BOF_FOURCC(a, b, c, d)                                     \
  (((uint32_t)(a)) | ((uint32_t)(b) << 8) |       /* NOLINT */ \
   ((uint32_t)(c) << 16) | ((uint32_t)(d) << 24)) /* NOLINT */

enum BOF_ROTATION
{
  BOF_ROTATION_0 = 0,      // No rotation.
  BOF_ROTATION_90 = 90,    // Rotate 90 degrees clockwise.
  BOF_ROTATION_180 = 180,  // Rotate 180 degrees.
  BOF_ROTATION_270 = 270,  // Rotate 270 degrees clockwise.
};

struct BOF2D_EXPORT BOF2DPARAM
{
  bool Dummy_B;

  BOF2DPARAM()
  {
    Reset();
  }

  void Reset()
  {
    Dummy_B = false;
  }
};
struct BOF2D_EXPORT BOF_RECT;

/*!
* Summary
* Definition of a 2D point entity
*/
struct BOF2D_EXPORT BOF_POINT_2D
{
  int32_t x_S32;                    /*! Point x coordinate*/
  int32_t y_S32;                    /*! Point y coordinate*/
  BOF_POINT_2D()
  {
    Reset();
  }

  BOF_POINT_2D(int32_t _x_S32, int32_t _y_S32)
  {
    x_S32 = _x_S32;
    y_S32 = _y_S32;
  }

  void Reset()
  {
    x_S32 = 0;
    y_S32 = 0;
  }

  bool IsInside(const BOF_RECT &_rBox) const;
  //  {
  //    return ((_rBox.Left_S32 <= x_S32) && (_rBox.Top_S32 <= y_S32) && (_rBox.Right_S32 >= x_S32) && (_rBox.Bottom_S32 >= y_S32));
  //  }
};

/*!
* Summary
* Definition of a 3D point entity
*/
struct BOF2D_EXPORT BOF_POINT_3D
{
  int32_t x_S32;                    /*! Point x coordinate*/
  int32_t y_S32;                    /*! Point y coordinate*/
  int32_t z_S32;                    /*! Point z coordinate*/
  BOF_POINT_3D()
  {
    Reset();
  }

  BOF_POINT_3D(int32_t _x_S32, int32_t _y_S32, int32_t _z_S32)
  {
    x_S32 = _x_S32;
    y_S32 = _y_S32;
    z_S32 = _z_S32;
  }

  void Reset()
  {
    x_S32 = 0;
    y_S32 = 0;
    z_S32 = 0;
  }
};

#if 0
struct BOF2D_EXPORT BOF_SIZE_FLOAT
{
  float    Width_f;                    /*! Width value*/
  float    Height_f;                   /*! Height value*/
  BOF_SIZE_FLOAT()
  {
    Reset();
  }
  BOF_SIZE_FLOAT(float _Width_f, float _Height_f)
  {
    Width_f = _Width_f;
    Height_f = _Height_f;
  }
  void     Reset()
  {
    Width_f = 0;
    Height_f = 0;
  }
};
#endif

/*!
* Summary
* Definition of a rectangle zone
*/
struct BOF2D_EXPORT BOF_RECT
{
  int32_t Left_S32;                 /*! Rectangle zone left x position*/
  int32_t Right_S32;                /*! Rectangle zone right x position outside of rect: Width_U32  = (_rRect_X.Right_S32 - _rRect_X.Left_S32)*/
  int32_t Top_S32;                  /*! Rectangle zone top y position*/
  int32_t Bottom_S32;               /*! Rectangle zone bottom y position outside of rect: Height_U32 = (_rRect_X.Bottom_S32 - _rRect_X.Top_S32);*/
  BOF_RECT()
  {
    Reset();
  }

  BOF_RECT(BOF_POINT_2D _TopLeft_X, BOF_POINT_2D _BottomRight_X)
  {
    Top_S32 = _TopLeft_X.y_S32;
    Left_S32 = _TopLeft_X.x_S32;
    Bottom_S32 = _BottomRight_X.y_S32;
    Right_S32 = _BottomRight_X.x_S32;
  }

  BOF_RECT(int32_t _x_S32, int32_t _y_S32, uint32_t _Width_U32, uint32_t _Height_U32)
  {
    Left_S32 = _x_S32;
    Right_S32 = _x_S32 + _Width_U32;
    Top_S32 = _y_S32;
    Bottom_S32 = _y_S32 + _Height_U32;
  }

  void Reset()
  {
    Left_S32 = 0;
    Right_S32 = 0;
    Top_S32 = 0;
    Bottom_S32 = 0;
  }

  bool IsInside(const BOF_RECT &_rBox) const
  {
    return ((_rBox.Left_S32 <= Left_S32) && (_rBox.Top_S32 <= Top_S32) && (_rBox.Right_S32 >= Right_S32) && (_rBox.Bottom_S32 >= Bottom_S32));
  }

  uint32_t Width() const
  {
    return Right_S32 - Left_S32;
  }

  uint32_t Height() const
  {
    return Bottom_S32 - Top_S32;
  }

  BOF::BOF_SIZE Size() const
  {
    return BOF::BOF_SIZE(Width(), Height());
  }
};

#pragma pack (1)
#if 0   //In BofStd
/*!
* Summary
* Definition of a color in the RGBA color space
*/
struct BOF2D_EXPORT BOF_RGBA
{
  uint8_t r_U8;                     /*! Color R component(Red)*/
  uint8_t g_U8;                     /*! Color G component(Greeen)*/
  uint8_t b_U8;                     /*! Color B component(Blue)*/
  uint8_t a_U8;                     /*! Color alpha component(Opacity)*/
  BOF_RGBA()
  {
    Reset();
  }

  BOF_RGBA(uint8_t _r_U8, uint8_t _g_U8, uint8_t _b_U8, uint8_t _a_U8)
  {
    r_U8 = _r_U8;
    g_U8 = _g_U8;
    b_U8 = _b_U8;
    a_U8 = _a_U8;
  }

  void Reset()
  {
    r_U8 = 0;
    g_U8 = 0;
    b_U8 = 0;
    a_U8 = 0;
  }
};
#endif
/*!
* Summary
* Definition of a color in the YUVA color space
*/
struct BOF2D_EXPORT BOF_YUVA
{
  uint8_t y_U8;                     /*! Color Y component(Luminance)*/
  uint8_t u_U8;                     /*! Color U component(Chrominance)*/
  uint8_t v_U8;                     /*! Color V component(Chrominance)*/
  uint8_t a_U8;                     /*! Color alpha component(Opacity)*/
  BOF_YUVA()
  {
    Reset();
  }

  BOF_YUVA(uint8_t _y_U8, uint8_t _u_U8, uint8_t _v_U8, uint8_t _a_U8)
  {
    y_U8 = _y_U8;
    u_U8 = _u_U8;
    v_U8 = _v_U8;
    a_U8 = _a_U8;
  }

  void Reset()
  {
    y_U8 = 0;
    u_U8 = 0;
    v_U8 = 0;
    a_U8 = 0;
  }
};


#if 0
struct BOF2D_EXPORT BOF_PALETTE_ENTRY
{
  uint8_t r_U8;
  uint8_t g_U8;
  uint8_t b_U8;
  uint8_t Flg_U8;

  BOF_PALETTE_ENTRY()
  {
    Reset();
  }

  void Reset()
  {
    r_U8 = 0;
    g_U8 = 0;
    b_U8 = 0;
    Flg_U8 = 0;
  }
};
#endif

#pragma pack ()

extern const BOF_YUVA GL_pYuvRainbow75_X[];
extern const BOF_YUVA GL_pYuvRainbow100_X[];
extern const BOF_YUVA GL_pYuvRainbowHd_X[];
extern const BOF_YUVA GL_pYuvWobNair_X[];
extern const BOF_YUVA GL_YuvWhite_X;
extern const BOF_YUVA GL_YuvNeg4Ire_X;
extern const BOF_YUVA GL_YuvPos4Ire_X;
extern const BOF_YUVA GL_YuvIPixel_X;
extern const BOF_YUVA GL_YuvQPixel_X;
extern const BOF_YUVA GL_YuvGray40_X;
extern const BOF_YUVA GL_YuvGray15_X;
extern const BOF_YUVA GL_YuvCyan_X;
extern const BOF_YUVA GL_YuvYellow_X;
extern const BOF_YUVA GL_YuvRed_X;
extern const BOF_YUVA GL_YuvGreen_X;
extern const BOF_YUVA GL_YuvBlue_X;
extern const BOF_YUVA GL_YuvBlack0_X;
extern const BOF_YUVA GL_YuvBlack2_X;
extern const BOF_YUVA GL_YuvBlack4_X;
extern const BOF_YUVA GL_YuvNeg2_X;

BOF2D_EXPORT std::string Bof_GetVersion();
BOF2D_EXPORT BOFERR Bof_Initialize(const BOF2DPARAM &_r2dParam_X);
BOF2D_EXPORT BOFERR Bof_Shutdown();
BOF2D_EXPORT BOFERR Bof_ProcessEvent();
BOF2D_EXPORT BOFERR Bof_LookForZoneCoordinate(BOF_RECT &_rRect_X, uint32_t _BitCount_U32, void *_pData, uint32_t _Pitch_U32, uint32_t _Color_U32);
BOF2D_EXPORT BOFERR Bof_EraseZoneBorder(BOF_RECT &_rRect_X, uint32_t _BitCount_U32, void *_pData, uint32_t _Pitch_U32);
BOF2D_EXPORT BOFERR Bof_DecimateGraphicData(uint8_t _BytePerPixel_UB, uint8_t *_pData_UB, uint32_t _Width_U32, uint32_t _Height_U32, float _DecimationStepX_f, float _DecimationStepY_f);
BOF2D_EXPORT BOFERR Bof_SwapColorEntries(uint8_t _BytePerPixel_UB, uint8_t *pData_UB, uint32_t _Width_U32, uint32_t _Height_U32, uint32_t _ColorEntry1_U32, uint32_t _ColorEntry2_U32);

BOF2D_EXPORT BOFERR Bof2d_SdlCheckIfError(int _SdlErrorCode_i, const std::string &_rErrorContext_S, const std::string &_rFile_S, const std::string &_rFunction_S, uint32_t _Line_U32);
#define SDL_CHK_IF_ERR(Sts, Ctx, Rts)  {const char *pFile_c; BOF_GET_FILE_FROM_PATH(__FILE__, pFile_c); Rts = BOF2D::Bof2d_SdlCheckIfError(Sts, Ctx, pFile_c, __func__, __LINE__);}

BOF2D_EXPORT BOFERR Bof2d_FfmpegCheckIfError(int _FfmpegErrorCode_i, const std::string &_rErrorContext_S, const std::string &_rFile_S, const std::string &_rFunction_S, uint32_t _Line_U32);
#define FFMPEG_CHK_IF_ERR(Sts, Ctx, Rts)  {const char *pFile_c; BOF_GET_FILE_FROM_PATH(__FILE__, pFile_c); Rts = BOF2D::Bof2d_FfmpegCheckIfError(Sts, Ctx, pFile_c, __func__, __LINE__);}

END_BOF2D_NAMESPACE()

extern BOF2D_EXPORT BOF2D::BOF2DPARAM GL_Bof2dParam_X;
